getPattern = (channel, i) => synth.song.channels[channel - 1].patterns[i-1]

function shiftBar(channel, bari, num, over){
    let ch = synth.song.channels[channel - 1]
    const {bars, patterns} = ch
    let patternID = bars[bari - 1], max = Math.max(...bars)

    if(patternID == 0 && max-1 < patterns.length){
        bars[bari-1] = max
        patternID = max  
    }
    else if(!patternID){
        return true
    }

    const pattern = patterns[patternID-1]

    let leftovers = shiftPattern(pattern, num, over)

    if(over && leftovers){
        leftovers.forEach(leftover => {
            shiftBar(channel, bari+leftover[1], num, over)
            let pattern = patterns[bars[bari+leftover[1]-1]-1]
            if(pattern){
                let note = pattern.notes
                if(leftover[1]==-1)
                    notes.push(leftover[0])
                else
                    notes.unshift(leftover[0])
            }
        })
    }
}

function shiftPattern(pattern, n, overlapn){
    let leftover = []
    //print(patterns)
    n = n * rhythm
    let ind = 0
    pattern.notes.forEach(note => {
        let [ns, ne] = [note.start + n, note.end + n]
        if(overlapn && (ns<0||ne>beats)){
            const [a,b,c] = (ns < 0)?[mod(ns,beats), ne<0?mod(ne):beats,-1]:(ne > beats)?[ns-beats, ne-beats,1]:[NaN,NaN,NaN]
            print(a, b, ns, ne, ns%beats, ne%beats, c)
            let nn = new beepbox.classes.Note(0, clamp(a, 0, beats), clamp(b, 0, beats), note.vol, note.fade)
            nn.pitches = note.pitches.map((x) => x)

            leftover.push([nn, c])
        }
        note.placement = [clamp(ns, 0, beats),clamp(ne, 0, beats)]

        if(note.start >= beats)
            pattern.notes.splice(ind, 1)
       // print(pattern.notes[ind])
        ind++
    })

    return leftover.length > 0?leftover:false
}


shiftBar(1, 2, 3)