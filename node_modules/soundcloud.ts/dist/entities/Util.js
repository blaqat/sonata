"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
var axios_1 = require("axios");
var fs = require("fs");
var path = require("path");
var index_1 = require("./index");
var Util = /** @class */ (function () {
    function Util(api) {
        var _this = this;
        this.api = api;
        this.playlists = new index_1.Playlists(this.api);
        this.users = new index_1.Users(this.api);
        this.tracks = new index_1.Tracks(this.api);
        /**
         * Gets the direct streaming link of a track.
         */
        this.streamLink = function (songUrl) { return __awaiter(_this, void 0, void 0, function () {
            var headers, html, match, url, connect;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        headers = {
                            "referer": "soundcloud.com",
                            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36"
                        };
                        if (songUrl.includes("m.soundcloud.com"))
                            songUrl = songUrl.replace("m.soundcloud.com", "soundcloud.com");
                        if (!songUrl.includes("soundcloud.com"))
                            songUrl = "https://soundcloud.com/" + songUrl;
                        return [4 /*yield*/, axios_1["default"].get(songUrl, { headers: headers })];
                    case 1:
                        html = _b.sent();
                        match = (_a = html.data.match(/(?<=,{"url":")(.*?)(progressive)/)) === null || _a === void 0 ? void 0 : _a[0];
                        connect = match.includes("secret_token") ? "&client_id=" + this.api.clientID : "?client_id=" + this.api.clientID;
                        if (!match) return [3 /*break*/, 3];
                        return [4 /*yield*/, axios_1["default"].get(match + connect, { headers: headers }).then(function (r) { return r.data.url; })["catch"](function () {
                                return Promise.reject("client id expired");
                            })];
                    case 2:
                        url = _b.sent();
                        return [3 /*break*/, 4];
                    case 3: return [2 /*return*/, null];
                    case 4: return [2 /*return*/, url];
                }
            });
        }); };
        /**
         * Downloads the mp3 stream of a track.
         */
        this.downloadTrackStream = function (songUrl, title, folder) { return __awaiter(_this, void 0, void 0, function () {
            var headers, html, match, url, connect, finalMP3, binary;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (title.endsWith(".mp3"))
                            title = title.replace(".mp3", "");
                        headers = {
                            "referer": "soundcloud.com",
                            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36"
                        };
                        if (songUrl.includes("m.soundcloud.com"))
                            songUrl = songUrl.replace("m.soundcloud.com", "soundcloud.com");
                        if (!songUrl.includes("soundcloud.com"))
                            songUrl = "https://soundcloud.com/" + songUrl;
                        return [4 /*yield*/, axios_1["default"].get(songUrl, { headers: headers })
                            // const match = html.data.match(/(?<="transcodings":\[{"url":")(.*?)(?=")/)?.[0]
                        ];
                    case 1:
                        html = _b.sent();
                        match = (_a = html.data.match(/(?<=,{"url":")(.*?)(progressive)/)) === null || _a === void 0 ? void 0 : _a[0];
                        connect = match.includes("secret_token") ? "&client_id=" + this.api.clientID : "?client_id=" + this.api.clientID;
                        if (!match) return [3 /*break*/, 3];
                        return [4 /*yield*/, axios_1["default"].get(match + connect, { headers: headers }).then(function (r) { return r.data.url; })["catch"](function () {
                                return Promise.reject("client id expired");
                            })];
                    case 2:
                        url = _b.sent();
                        return [3 /*break*/, 4];
                    case 3: return [2 /*return*/, null];
                    case 4:
                        finalMP3 = path.join(folder, title + ".mp3");
                        return [4 /*yield*/, axios_1["default"].get(url, { headers: headers, responseType: "arraybuffer" }).then(function (r) { return r.data; })];
                    case 5:
                        binary = _b.sent();
                        fs.writeFileSync(finalMP3, Buffer.from(binary, "binary"));
                        return [2 /*return*/, finalMP3];
                }
            });
        }); };
        /**
         * Gets a track title from the page
         */
        this.getTitle = function (songUrl) { return __awaiter(_this, void 0, void 0, function () {
            var headers, html, title;
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        headers = {
                            "referer": "soundcloud.com",
                            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36"
                        };
                        return [4 /*yield*/, axios_1["default"].get(songUrl, { headers: headers }).then(function (r) { return r.data; })];
                    case 1:
                        html = _c.sent();
                        title = (_b = (_a = html.match(/(?<="og:title" content=")(.*?)(?=")/)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.replace(/\//g, "");
                        return [2 /*return*/, title];
                }
            });
        }); };
        /**
         * Downloads a track on Soundcloud.
         */
        this.downloadTrack = function (trackResolvable, folder) { return __awaiter(_this, void 0, void 0, function () {
            var track, result, dest, url, title;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!folder)
                            folder = "./";
                        if (!fs.existsSync(folder))
                            fs.mkdirSync(folder, { recursive: true });
                        if (!trackResolvable.hasOwnProperty("downloadable")) return [3 /*break*/, 4];
                        track = trackResolvable;
                        if (!(track.downloadable === true)) return [3 /*break*/, 2];
                        return [4 /*yield*/, axios_1["default"].get(track.download_url, { responseType: "arraybuffer", params: { client_id: this.api.clientID } })];
                    case 1:
                        result = _a.sent();
                        dest = path.join(folder, track.title.replace(/\//g, "") + "." + result.headers["x-amz-meta-file-type"]);
                        fs.writeFileSync(dest, Buffer.from(result.data, "binary"));
                        return [2 /*return*/, dest];
                    case 2: return [2 /*return*/, this.downloadTrackStream(track.permalink_url, track.title.replace(/\//g, ""), folder)];
                    case 3: return [3 /*break*/, 6];
                    case 4:
                        url = trackResolvable;
                        return [4 /*yield*/, this.getTitle(url)];
                    case 5:
                        title = _a.sent();
                        return [2 /*return*/, this.downloadTrackStream(url, title, folder)];
                    case 6: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Downloads an array of tracks.
         */
        this.downloadTracks = function (tracks, dest, limit) { return __awaiter(_this, void 0, void 0, function () {
            var resultArray, i, result, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!limit)
                            limit = tracks.length;
                        resultArray = [];
                        i = 0;
                        _b.label = 1;
                    case 1:
                        if (!(i < limit)) return [3 /*break*/, 6];
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.downloadTrack(tracks[i], dest)];
                    case 3:
                        result = _b.sent();
                        resultArray.push(result);
                        return [3 /*break*/, 5];
                    case 4:
                        _a = _b.sent();
                        return [3 /*break*/, 5];
                    case 5:
                        i++;
                        return [3 /*break*/, 1];
                    case 6: return [2 /*return*/, resultArray];
                }
            });
        }); };
        /**
         * Downloads all the tracks from the search query.
         */
        this.downloadSearch = function (query, dest, limit) { return __awaiter(_this, void 0, void 0, function () {
            var tracks;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.tracks.searchV2({ q: query })];
                    case 1:
                        tracks = _a.sent();
                        return [2 /*return*/, this.downloadTracks(tracks.collection, dest, limit)];
                }
            });
        }); };
        /**
         * @deprecated
         * Downloads all of a users favorites.
         */
        this.downloadFavorites = function (userResolvable, dest, limit) { return __awaiter(_this, void 0, void 0, function () {
            var tracks;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.users.favorites(userResolvable)];
                    case 1:
                        tracks = _a.sent();
                        return [2 /*return*/, this.downloadTracks(tracks, dest, limit)];
                }
            });
        }); };
        /**
         * Downloads all the tracks in a playlist.
         */
        this.downloadPlaylist = function (playlistResolvable, dest, limit) { return __awaiter(_this, void 0, void 0, function () {
            var playlist;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.playlists.getAlt(playlistResolvable)];
                    case 1:
                        playlist = _a.sent();
                        return [2 /*return*/, this.downloadTracks(playlist.tracks, dest, limit)];
                }
            });
        }); };
        /**
         * Same as downloadTrack, but it returns a readable stream.
         */
        this.streamTrack = function (trackResolvable, folder) { return __awaiter(_this, void 0, void 0, function () {
            var track, result, dest, dest, url, title, dest;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!folder)
                            folder = "./";
                        if (!fs.existsSync(folder))
                            fs.mkdirSync(folder, { recursive: true });
                        if (!trackResolvable.hasOwnProperty("downloadable")) return [3 /*break*/, 5];
                        track = trackResolvable;
                        if (!(track.downloadable === true)) return [3 /*break*/, 2];
                        return [4 /*yield*/, axios_1["default"].get(track.download_url, { responseType: "arraybuffer", params: { client_id: this.api.clientID, oauth_token: this.api.oauthToken } })];
                    case 1:
                        result = _a.sent();
                        dest = path.join(folder, track.title.replace(/\//g, "") + "." + result.headers["x-amz-meta-file-type"]);
                        fs.writeFileSync(dest, Buffer.from(result.data, "binary"));
                        return [2 /*return*/, fs.createReadStream(dest)];
                    case 2: return [4 /*yield*/, this.downloadTrackStream(track.permalink_url, track.title.replace(/\//g, ""), folder)];
                    case 3:
                        dest = _a.sent();
                        return [2 /*return*/, fs.createReadStream(dest)];
                    case 4: return [3 /*break*/, 8];
                    case 5:
                        url = trackResolvable;
                        return [4 /*yield*/, this.getTitle(url)];
                    case 6:
                        title = _a.sent();
                        return [4 /*yield*/, this.downloadTrackStream(url, title, folder)];
                    case 7:
                        dest = _a.sent();
                        return [2 /*return*/, fs.createReadStream(dest)];
                    case 8: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Downloads a track's song cover.
         */
        this.downloadSongCover = function (trackResolvable, folder) { return __awaiter(_this, void 0, void 0, function () {
            var track, artwork, title, dest, arrayBuffer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!folder)
                            folder = "./";
                        if (!fs.existsSync(folder))
                            fs.mkdirSync(folder, { recursive: true });
                        if (!trackResolvable.hasOwnProperty("artwork_url")) return [3 /*break*/, 1];
                        track = trackResolvable;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.tracks.getV2(trackResolvable)];
                    case 2:
                        track = _a.sent();
                        _a.label = 3;
                    case 3:
                        artwork = track.artwork_url ? track.artwork_url : track.user.avatar_url;
                        artwork = artwork.replace(".jpg", ".png").replace("-large", "-t500x500");
                        title = track.title.replace(/\//g, "");
                        dest = path.join(folder, title + ".png");
                        return [4 /*yield*/, axios_1["default"].get(artwork, { responseType: "arraybuffer", params: { client_id: this.api.clientID, oauth_token: this.api.oauthToken } }).then(function (r) { return r.data; })];
                    case 4:
                        arrayBuffer = _a.sent();
                        fs.writeFileSync(dest, Buffer.from(arrayBuffer, "binary"));
                        return [2 /*return*/, dest];
                }
            });
        }); };
        /**
         * Utility for awaiting a stream.Writable
         */
        this.awaitStream = function (writeStream) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        writeStream.on("finish", resolve);
                        writeStream.on("error", reject);
                    })];
            });
        }); };
        /**
         * Removes a directory recursively
         */
        this.removeDirectory = function (dir) {
            if (dir === "/" || dir === "./")
                return;
            if (fs.existsSync(dir)) {
                fs.readdirSync(dir).forEach(function (entry) {
                    var entryPath = path.join(dir, entry);
                    if (fs.lstatSync(entryPath).isDirectory()) {
                        this.removeDirectory(entryPath);
                    }
                    else {
                        fs.unlinkSync(entryPath);
                    }
                });
                try {
                    fs.rmdirSync(dir);
                }
                catch (e) {
                    console.log(e);
                }
            }
        };
    }
    return Util;
}());
exports.Util = Util;
